#region usings

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Discord;
using Discord.WebSocket;

#endregion

namespace DiscordNetCore
{
    internal class Program
    {
        private readonly DiscordSocketClient _client;

        private string Prefix
        {
            get { return BotUser.Default.Prefix; }
            set
            {
                BotUser.Default.Prefix = value;
                BotUser.Default.Save();
            }
        }

        public Program()
        {
            // It is recommended to Dispose of a client when you are finished
            // using it, at the end of your app's lifetime.
            _client = new DiscordSocketClient();

            _client.Log += LogAsync;
            _client.Ready += ReadyAsync;
            _client.MessageReceived += MessageReceivedAsync;
        }

        private string Token => $"{BotUser.Default.Token}";

        // Discord.Net heavily utilizes TAP for async, so we create
        // an asynchronous context from the beginning.
        private static void Main()
        {
            while (true)
            {
                if (File.Exists("BotToken.txt"))
                {
                    StreamReader sr = new StreamReader("BotToken.txt");
                    bool del = true;

                    while (!sr.EndOfStream)
                    {
                        if (sr.ReadLine().ToLower().StartsWith("BotToken="))
                            del = false;
                    }

                    sr.Dispose();

                    if(del)
                        File.Delete("BotToken.txt");
                }
                else
                {
                    StreamWriter sw = new StreamWriter("BotToken.txt");
                    sw.WriteLine($"## This is an autogenerated file generated at {DateTime.Now.ToLongDateString()}.\n" +
                                 $"## Please replace the text <token> with your bot token.\n" +
                                 $"\n" +
                                 $"BotToken=<token>\n");
                    sw.Flush();
                    sw.Close();
                    sw.Dispose();

                    foreach (string file in Directory.GetFiles("./", "*.txt"))
                    {
                        Console.WriteLine(file);
                    }

                    Console.WriteLine("Generated default file and opening...");
                    Console.Read();
                    Process.Start("BotToken.txt");
                }
            }

            new Program().MainAsync().GetAwaiter().GetResult();
        }

        private async Task MainAsync()
        {
            // Tokens should be considered secret data, and never hard-coded.
            await _client.LoginAsync(TokenType.Bot, Token, false);
            await _client.StartAsync();

            // Block the program until it is closed.
            await Task.Delay(-1);
        }

        private Task LogAsync(LogMessage log)
        {
            Console.WriteLine(log.ToString());
            return Task.CompletedTask;
        }

        // The Ready event indicates that the client has opened a
        // connection and it is now safe to access the cache.
        private Task ReadyAsync()
        {
            Console.WriteLine($"{_client.CurrentUser} is connected!");

            return Task.CompletedTask;
        }

        // This is not the recommended way to write a bot - consider
        // reading over the Commands Framework sample.
        private async Task MessageReceivedAsync(SocketMessage message)
        {
            if (message.Channel is ITextChannel)
            {
                Console.WriteLine($"IText: {message.Channel}");
            }
            else
            {
                Console.WriteLine($"Not: {message.Channel}");
            }

            if (message.Author.Id == _client.CurrentUser.Id)
                return;

            Log($"{message.Channel}/{message.Author.Username}#{message.Author.Discriminator} : {message.Content}",
                false);

            if (message.MentionedUsers.Count != 0)
            {
                Log("Users mentioned", false);
                foreach (SocketUser user in message.MentionedUsers)
                {
                    await user.SendMessageAsync($"You got mentioned by {message.Author.Username}#{message.Author.Discriminator} in {message.Channel.Name}");
                    Log($"{user.Username}#{user.Discriminator}");
                }
            }

            if (message.Content.StartsWith(Prefix))
            {
                string[] messageStrings = message.Content.Split(' ');
                messageStrings[0] = messageStrings[0].Remove(0, Prefix.Length);

                switch (messageStrings[0].ToLower())
                {
                    case "ping":
                        await message.Channel.SendMessageAsync("pong!");
                        break;
                    case "prefix":
                        if (messageStrings.Length == 1)
                        {
                            await message.Channel.SendMessageAsync($"Prefix: `{Prefix}`");
                            break;
                        }
                        else if (messageStrings.Length > 2)
                        {
                            await message.Channel.SendMessageAsync(
                                "Too many arguments!\nUsage:```\nprefix <prefix>\n```");
                            break;
                        }

                        Prefix = messageStrings[1];
                        await message.Channel.SendMessageAsync($"Prefix changed to `{Prefix}`");
                        break;
                    case "get-user":
                        if (messageStrings.Length == 2)
                        {
                            IReadOnlyCollection<SocketGuildUser> socketGuildUsers = _client.Guilds.First().Users;
                            List<SocketGuildUser> userMatchList = new List<SocketGuildUser>();

                            foreach (SocketGuildUser user in socketGuildUsers)
                            {
                                if($"{user.Username}#{user.DiscriminatorValue} {user.Nickname}".ToLower().Contains(messageStrings[1].ToLower()))
                                    userMatchList.Add(user);
                            }

                            string userString = "";
                            foreach (SocketGuildUser user in userMatchList)
                            {
                                string m = $"`{user.Nickname}` {user.Username}#{user.DiscriminatorValue} {user.Id}".ToLower();
                                Log(m);
                                userString += m + "\n";
                            }

                            await message.Channel.SendMessageAsync($"Found users:\n```\n{userString}\n```");
                            break;
                        }

                        await message.Channel.SendMessageAsync($"Correct usage:\n```\nuid <username>\n```");
                        break;
                }
            }
        }

        private void Log(string message, bool useIndent = true, ConsoleColor color = ConsoleColor.Gray)
        {
            Console.ForegroundColor = color;

            string time = DateTime.Now.ToLongTimeString();
            string indent = "";

            if (useIndent)
            {
                for (int i = 0; i < time.Length; i++)
                {
                    indent += " ";
                }

                time = indent;
            }

            Console.WriteLine($"{time} {message}");
        }
    }
}