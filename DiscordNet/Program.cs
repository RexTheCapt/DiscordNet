#region usings

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using Discord;
using Discord.WebSocket;

#endregion

namespace DiscordNet
{
    public class InstanceId
    {
        private int _id;

        public InstanceId()
        {
            NewId();
        }

        public string NewId()
        {
            Random rdm = new Random();
            _id = rdm.Next(int.MinValue, int.MaxValue);
            return Id();
        }

        public string Id()
        {
            return _id.ToString("x8");
        }
    }

    internal class Program
    {
        private readonly DiscordSocketClient _client;

        private static string Version
        {
            get
            {
                Assembly assembly = Assembly.GetExecutingAssembly();
                FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);
                string version = fvi.FileVersion;
                return version;
            }
        }

        private string Prefix
        {
            get => BotUser.Default.Prefix;
            set
            {
                BotUser.Default.Prefix = value;
                BotUser.Default.Save();
            }
        }
        private string Token => $"{BotUser.Default.Token}";
        
        InstanceId instanceId = new InstanceId();

        private bool _botPaused;

        #region Startup functions

        public Program()
        {
            // It is recommended to Dispose of a client when you are finished
            // using it, at the end of your app's lifetime.
            _client = new DiscordSocketClient();

            _client.Log += LogAsync;
            _client.Ready += ReadyAsync;
            _client.MessageReceived += MessageReceivedAsync;
        }
        // Discord.Net heavily utilizes TAP for async, so we create
        // an asynchronous context from the beginning.
        private static void Main()
        {
            Console.Title = "Discord Bot";

            Log.Info($"Version: {Version}");

            bool hasToken = false;

            while (!hasToken)
                if (File.Exists("BotToken.txt"))
                {
                    StreamReader sr = new StreamReader("BotToken.txt");
                    bool del = true;

                    while (!sr.EndOfStream)
                    {
                        string read = sr.ReadLine();

                        if (read != null && read.StartsWith("BotToken="))
                        {
                            del = false;

                            string[] tmp = read.Split('=');

                            BotUser.Default.Token = tmp[1];
                            BotUser.Default.Save();

                            hasToken = true;
                        }
                    }

                    sr.Dispose();

                    if (del)
                        File.Delete("BotToken.txt");
                }
                else
                {
                    GenerateTokenFile();
                }

            try
            {
                new Program().MainAsync().GetAwaiter().GetResult();
            }
            catch (Exception e)
            {
                if (e.ToString().Contains("401: Unauthorized"))
                {
                    Log.Error("Unauthorized... resetting token file...");
                    File.Delete("BotToken.txt");
                    GenerateTokenFile();
                }
                else
                {
                    Log.Error(e);
                }
            }
        }
        private static void GenerateTokenFile()
        {
            StreamWriter sw = new StreamWriter("BotToken.txt");
            sw.WriteLine($"## This is an autogenerated file generated at {DateTime.Now.ToLongDateString()}.\n" +
                         $"## Please replace the text <token> with your bot token. Please input your owner ID to get full access (require bot restart).\n" +
                         $"\n" +
                         $"BotToken=<token>\n" +
                         $"OwnerID=<owner>\n");

            sw.Flush();
            sw.Close();
            sw.Dispose();

            foreach (string file in Directory.GetFiles("./", "*.txt")) Console.WriteLine(file);

            Log.Info("Generated default file and opening...");

            Process.Start("BotToken.txt");

            Environment.Exit(0);
        }
        private async Task MainAsync()
        {
            // Tokens should be considered secret data, and never hard-coded.
            await _client.LoginAsync(TokenType.Bot, Token, false);
            await _client.StartAsync();
            
            Log.Info($"Instance ID: {instanceId.Id()}");

            #region Set Owner ID

            {
                bool optionFound = false;

                StreamReader sr = new StreamReader("BotToken.txt");
                while (!sr.EndOfStream)
                {
                    string read = sr.ReadLine();

                    if (read != null && read.StartsWith("OwnerID="))
                    {
                        optionFound = true;

                        try
                        {
                            string[] split = read.Split('=');
                            BotUser.Default.OwnerID = Convert.ToUInt64(split[1]);
                            BotUser.Default.Save();
                            Log.Info($"Owner ID set to {BotUser.Default.OwnerID}");
                        }
                        catch
                        {
                            Log.Error("Unable to set Owner ID");
                        }

                        break;
                    }
                }

                if (!optionFound)
                {
                    Log.Error("OwnerID not found in BotToken.txt");
                }
            }

            #endregion

            // Block the program until it is closed.
            await Task.Delay(-1);
        }
        private Task ReadyAsync()
        {
            Log.Info($"{_client.CurrentUser} is connected!");

            return Task.CompletedTask;
        }

        #endregion

        private Task LogAsync(LogMessage log)
        {
            Log.Write(log.ToString());
            return Task.CompletedTask;
        }

        // This is not the recommended way to write a bot - consider
        // reading over the Commands Framework sample.
        private async Task MessageReceivedAsync(SocketMessage message)
        {
            Commands commands = new Commands();

            if (message.Author.Id == _client.CurrentUser.Id)
                return;

            bool isOwner = BotUser.Default.OwnerID == message.Author.Id;

            if (message.Channel is ITextChannel)
                Log.Write(
                    $"{message.Channel}/{message.Author.Username}#{message.Author.Discriminator} : {message.Content}");
            else
                Log.DmWrite($"DM/{message.Author.Username}#{message.Author.Discriminator} : {message.Content}");

            if (message.Author.Id == 288351323940847616 && message.Content.ToLower().Contains("school") &&
                message.Content.ToLower().Contains("boring"))
                await message.Channel.SendMessageAsync($"Stop complaining {message.Author.Mention}.");

            if (message.MentionedUsers.Count != 0)
            {
                Log.Write("Users mentioned");

                foreach (SocketUser user in message.MentionedUsers)
                    await user.SendMessageAsync(
                        $"You got mentioned by {message.Author.Username}#{message.Author.Discriminator} in {message.Channel.Name}");
            }

            if (!_botPaused && message.Content.StartsWith(Prefix) || (message.Channel is IDMChannel && !_botPaused))
            {
                string[] messageStrings = message.Content.Split(' ');

                if (message.Channel is ITextChannel) messageStrings[0] = messageStrings[0].Remove(0, Prefix.Length);

                switch (messageStrings[0].ToLower())
                {
                    case "ping":
                        await message.Channel.SendMessageAsync("pong!");
                        break;
                    case "prefix":
                        Prefix = await commands.Prefix(messageStrings, message, Prefix);
                        break;
                    case "get-user":
                        commands.GetUser(messageStrings, _client, message);
                        break;
                    case "shutdown":
                        await commands.Shutdown(message, isOwner);
                        break;
                    case "info":
                        await commands.Info(instanceId.Id(), message, _botPaused, _client);
                        break;
                    case "pause":
                        _botPaused = await commands.Pause(messageStrings[1], instanceId, isOwner, message);
                        break;
                }
            }
            else if (_botPaused)
            {
                string[] messageStrings = message.Content.Split(' ');
                if (message.Channel is ITextChannel) messageStrings[0] = messageStrings[0].Remove(0, Prefix.Length);

                switch (messageStrings[0].ToLower())
                {
                    case "continue":
                        _botPaused = await commands.Continue(messageStrings[1], instanceId, isOwner, message);
                        break;
                    case "info":
                        if (message.Channel is IDMChannel)
                        {
                            await commands.Info(instanceId.Id(), message, _botPaused, _client);
                        }
                        break;
                }
            }
        }
    }
}